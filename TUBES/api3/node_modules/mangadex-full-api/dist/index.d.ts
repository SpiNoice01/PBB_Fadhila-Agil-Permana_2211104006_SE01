/** MangaRequest */
interface MangaRequestSchema {
    title: LocalizedStringSchema;
    altTitles: LocalizedStringSchema[];
    description: LocalizedStringSchema;
    authors: string[];
    artists: string[];
    links: Record<string, string>;
    /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
    originalLanguage: string;
    lastVolume: string | null;
    lastChapter: string | null;
    publicationDemographic: 'shounen' | 'shoujo' | 'josei' | 'seinen' | null;
    status: 'completed' | 'ongoing' | 'cancelled' | 'hiatus';
    /**
     * Year of release
     * @min 1
     * @max 9999
     */
    year: number | null;
    contentRating: 'safe' | 'suggestive' | 'erotica' | 'pornographic';
    chapterNumbersResetOnNewVolume: boolean;
    tags: string[];
    /** @format uuid */
    primaryCover: string | null;
    /** @min 1 */
    version: number;
}
/** LocalizedString */
type LocalizedStringSchema = Record<string, string>;
/** MangaResponse */
interface MangaResponseSchema {
    result: 'ok' | 'error';
    /** @default "entity" */
    response: string;
    data: MangaSchema;
}
/** Relationship */
interface RelationshipSchema {
    /** @format uuid */
    id: string;
    type: string;
    /** Related Manga type, only present if you are on a Manga entity and a Manga relationship */
    related: 'monochrome' | 'main_story' | 'adapted_from' | 'based_on' | 'prequel' | 'side_story' | 'doujinshi' | 'same_franchise' | 'shared_universe' | 'sequel' | 'spin_off' | 'alternate_story' | 'alternate_version' | 'preserialization' | 'colored' | 'serialization';
    /** If Reference Expansion is applied, contains objects attributes */
    attributes: object | null;
}
/** Chapter */
interface ChapterSchema {
    /** @format uuid */
    id: string;
    type: 'chapter';
    attributes: ChapterAttributesSchema;
    relationships: RelationshipSchema[];
}
/** Manga */
interface MangaSchema {
    /** @format uuid */
    id: string;
    type: 'manga';
    attributes: MangaAttributesSchema;
    relationships: RelationshipSchema[];
}
/** ChapterAttributes */
interface ChapterAttributesSchema {
    /** @maxLength 255 */
    title: string | null;
    volume: string | null;
    /** @maxLength 8 */
    chapter: string | null;
    /** Count of readable images for this chapter */
    pages: number;
    /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
    translatedLanguage: string;
    /** @format uuid */
    uploader: string;
    /**
     * Denotes a chapter that links to an external source.
     * @maxLength 512
     * @pattern ^https?://
     */
    externalUrl: string | null;
    /** @min 1 */
    version: number;
    /** @format date-time */
    createdAt: Date;
    /** @format date-time */
    updatedAt: Date;
    /** @format date-time */
    publishAt: Date;
    /** @format date-time */
    readableAt: Date;
}
/** MangaAttributes */
interface MangaAttributesSchema {
    title: LocalizedStringSchema;
    altTitles: LocalizedStringSchema[];
    description: LocalizedStringSchema;
    isLocked: boolean;
    links: Record<string, string>;
    originalLanguage: string;
    lastVolume: string | null;
    lastChapter: string | null;
    publicationDemographic: 'shounen' | 'shoujo' | 'josei' | 'seinen' | null;
    status: 'completed' | 'ongoing' | 'cancelled' | 'hiatus';
    /** Year of release */
    year: number | null;
    contentRating: 'safe' | 'suggestive' | 'erotica' | 'pornographic';
    chapterNumbersResetOnNewVolume: boolean;
    availableTranslatedLanguages: string[];
    /** @format uuid */
    latestUploadedChapter: string;
    tags: TagSchema[];
    state: 'draft' | 'submitted' | 'published' | 'rejected';
    /** @min 1 */
    version: number;
    /** @format date-time */
    createdAt: Date;
    /** @format date-time */
    updatedAt: Date;
}
type MangaCreateSchema = MangaRequestSchema;
type MangaEditSchema = MangaRequestSchema;
type ChapterEditSchema = ChapterRequestSchema;
/** Response */
interface ResponseSchema {
    result: 'ok' | 'error';
}
/** ScanlationGroup */
interface ScanlationGroupSchema {
    /** @format uuid */
    id: string;
    type: 'scanlation_group';
    attributes: ScanlationGroupAttributesSchema;
    relationships: RelationshipSchema[];
}
/** ScanlationGroupAttributes */
interface ScanlationGroupAttributesSchema {
    name: string;
    altNames: LocalizedStringSchema[];
    website: string | null;
    ircServer: string | null;
    ircChannel: string | null;
    discord: string | null;
    contactEmail: string | null;
    description: string | null;
    /**
     * @format uri
     * @pattern ^https?://
     */
    twitter: string | null;
    /**
     * @format uri
     * @maxLength 128
     * @pattern ^https:\/\/www\.mangaupdates\.com\/(group|publisher)(s\.html\?id=\d+|\/[\w-]+\/?([\w-]+)?(\/)?)$
     */
    mangaUpdates: string | null;
    focusedLanguage: string[] | null;
    locked: boolean;
    official: boolean;
    verified: boolean;
    inactive: boolean;
    exLicensed: boolean;
    /**
     * Should respected ISO 8601 duration specification: https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @pattern ^(P([1-9]|[1-9][0-9])D)?(P?([1-9])W)?(P?T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$
     * @example "P4D"
     */
    publishDelay: string;
    /** @min 1 */
    version: number;
    /** @format date-time */
    createdAt: Date;
    /** @format date-time */
    updatedAt: Date;
}
/** User */
interface UserSchema {
    /** @format uuid */
    id: string;
    type: 'user';
    attributes: UserAttributesSchema;
    relationships: RelationshipSchema[];
}
/** UserAttributes */
interface UserAttributesSchema {
    username: string;
    roles: string[];
    /** @min 1 */
    version: number;
}
/** CreateScanlationGroup */
interface CreateScanlationGroupSchema {
    name: string;
    website?: string | null;
    ircServer?: string | null;
    ircChannel?: string | null;
    discord?: string | null;
    contactEmail?: string | null;
    description?: string | null;
    /**
     * @format uri
     * @pattern ^https?://twitter\.com
     */
    twitter?: string | null;
    /**
     * @maxLength 128
     * @pattern ^https:\/\/www\.mangaupdates\.com\/(group|publisher)(s\.html\?id=\d+|\/[\w-]+\/?([\w-]+)?(\/)?)$
     */
    mangaUpdates?: string | null;
    inactive?: boolean;
    /** @pattern ^P(([1-9]|[1-9][0-9])D)?(([1-9])W)?(T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$ */
    publishDelay?: string | null;
}
/** CustomListCreate */
interface CustomListCreateSchema {
    name: string;
    visibility?: 'public' | 'private';
    manga?: string[];
    /** @min 1 */
    version?: number;
}
/** CustomList */
interface CustomListSchema {
    /** @format uuid */
    id: string;
    type: 'custom_list';
    attributes: CustomListAttributesSchema;
    relationships: RelationshipSchema[];
}
/** CustomListAttributes */
interface CustomListAttributesSchema {
    name: string;
    visibility: 'private' | 'public';
    /** @min 1 */
    version: number;
}
/** CoverResponse */
interface CoverResponseSchema {
    result: string;
    /** @default "entity" */
    response: string;
    data: CoverSchema;
}
/** Cover */
interface CoverSchema {
    /** @format uuid */
    id: string;
    type: 'cover_art';
    attributes: CoverAttributesSchema;
    relationships: RelationshipSchema[];
}
/** CoverAttributes */
interface CoverAttributesSchema {
    volume: string | null;
    fileName: string;
    description: string | null;
    locale: string | null;
    /** @min 1 */
    version: number;
    /** @format date-time */
    createdAt: Date;
    /** @format date-time */
    updatedAt: Date;
}
/** CoverEdit */
interface CoverEditSchema {
    /**
     * @minLength 0
     * @maxLength 8
     */
    volume: string | null;
    /**
     * @minLength 0
     * @maxLength 512
     */
    description?: string | null;
    /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
    locale?: string | null;
    /** @min 1 */
    version: number;
}
/** Author */
interface AuthorSchema {
    /** @format uuid */
    id: string;
    type: 'author';
    attributes: AuthorAttributesSchema;
    relationships: RelationshipSchema[];
}
/** AuthorAttributes */
interface AuthorAttributesSchema {
    name: string;
    imageUrl: string | null;
    biography: LocalizedStringSchema;
    /**
     * @format uri
     * @pattern ^https?://twitter\.com(/|$)
     */
    twitter: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?pixiv\.net(/|$)
     */
    pixiv: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?melonbooks\.co\.jp(/|$)
     */
    melonBook: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?fanbox\.cc(/|$)
     */
    fanBox: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?booth\.pm(/|$)
     */
    booth: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?nicovideo\.jp(/|$)
     */
    nicoVideo: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?skeb\.jp(/|$)
     */
    skeb: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?fantia\.jp(/|$)
     */
    fantia: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?tumblr\.com(/|$)
     */
    tumblr: string | null;
    /**
     * @format uri
     * @pattern ^https?://www\.youtube\.com(/|$)
     */
    youtube: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?weibo\.(cn|com)(/|$)
     */
    weibo: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?naver\.com(/|$)
     */
    naver: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?namicomi\.com(/|$)
     */
    namicomi: string | null;
    /**
     * @format uri
     * @pattern ^https?://
     */
    website: string | null;
    /** @min 1 */
    version: number;
    /** @format date-time */
    createdAt: Date;
    /** @format date-time */
    updatedAt: Date;
}
/** AuthorCreate */
interface AuthorCreateSchema {
    name: string;
    biography?: LocalizedStringSchema;
    /**
     * @format uri
     * @pattern ^https?://twitter\.com(/|$)
     */
    twitter?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?pixiv\.net(/|$)
     */
    pixiv?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?melonbooks\.co\.jp(/|$)
     */
    melonBook?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?fanbox\.cc(/|$)
     */
    fanBox?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?booth\.pm(/|$)
     */
    booth?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?nicovideo\.jp(/|$)
     */
    nicoVideo?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?skeb\.jp(/|$)
     */
    skeb?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?fantia\.jp(/|$)
     */
    fantia?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?tumblr\.com(/|$)
     */
    tumblr?: string | null;
    /**
     * @format uri
     * @pattern ^https?://www\.youtube\.com(/|$)
     */
    youtube?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?weibo\.(cn|com)(/|$)
     */
    weibo?: string | null;
    /**
     * @format uri
     * @pattern ^https?://([\w-]+\.)?naver\.com(/|$)
     */
    naver?: string | null;
    /**
     * @format uri
     * @pattern ^https?://
     */
    website?: string | null;
}
/** MappingIdBody */
interface MappingIdBodySchema {
    type: 'group' | 'manga' | 'chapter' | 'tag';
    ids: number[];
}
/** TagResponse */
interface TagResponseSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: TagSchema[];
    limit: number;
    offset: number;
    total: number;
}
/** Tag */
interface TagSchema {
    /** @format uuid */
    id: string;
    type: 'tag';
    attributes: TagAttributesSchema;
    relationships: RelationshipSchema[];
}
/** TagAttributes */
interface TagAttributesSchema {
    name: LocalizedStringSchema;
    description: LocalizedStringSchema;
    group: 'content' | 'format' | 'genre' | 'theme';
    /** @min 1 */
    version: number;
}
/** UserResponse */
interface UserResponseSchema {
    result: 'ok';
    /** @default "entity" */
    response: string;
    data: UserSchema;
}
/** UpdateMangaStatus */
interface UpdateMangaStatusSchema {
    status: 'reading' | 'on_hold' | 'plan_to_read' | 'dropped' | 're_reading' | 'completed' | null;
}
/** ChapterRequest */
interface ChapterRequestSchema {
    /** @maxLength 255 */
    title: string | null;
    volume: string | null;
    /** @maxLength 8 */
    chapter: string | null;
    /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
    translatedLanguage: string;
    /** @maxItems 10 */
    groups: string[];
    /** @min 1 */
    version: number;
}
/** CoverList */
interface CoverListSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: CoverSchema[];
    limit: number;
    offset: number;
    total: number;
}
/** ChapterList */
interface ChapterListSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: ChapterSchema[];
    limit: number;
    offset: number;
    total: number;
}
/** ScanlationGroupList */
interface ScanlationGroupListSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: ScanlationGroupSchema[];
    limit: number;
    offset: number;
    total: number;
}
type MangaRelationCreateSchema = MangaRelationRequestSchema;
/** MangaRelationRequest */
interface MangaRelationRequestSchema {
    /** @format uuid */
    targetManga: string;
    relation: 'monochrome' | 'main_story' | 'adapted_from' | 'based_on' | 'prequel' | 'side_story' | 'doujinshi' | 'same_franchise' | 'shared_universe' | 'sequel' | 'spin_off' | 'alternate_story' | 'alternate_version' | 'preserialization' | 'colored' | 'serialization';
}
/** MangaRelationList */
interface MangaRelationListSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: MangaRelationSchema[];
    limit: number;
    offset: number;
    total: number;
}
/** MangaRelationResponse */
interface MangaRelationResponseSchema {
    result: 'ok' | 'error';
    /** @default "entity" */
    response: string;
    data: MangaRelationSchema;
}
/** MangaRelation */
interface MangaRelationSchema {
    /** @format uuid */
    id: string;
    type: 'manga_relation';
    attributes: MangaRelationAttributesSchema;
    relationships: RelationshipSchema[];
}
/** MangaRelationAttributes */
interface MangaRelationAttributesSchema {
    relation: 'monochrome' | 'main_story' | 'adapted_from' | 'based_on' | 'prequel' | 'side_story' | 'doujinshi' | 'same_franchise' | 'shared_universe' | 'sequel' | 'spin_off' | 'alternate_story' | 'alternate_version' | 'preserialization' | 'colored' | 'serialization';
    /** @min 1 */
    version: number;
}
/** MangaList */
interface MangaListSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: MangaSchema[];
    limit: number;
    offset: number;
    total: number;
}
/** CustomListList */
interface CustomListListSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: CustomListSchema[];
    limit: number;
    offset: number;
    total: number;
}
/** UserList */
interface UserListSchema {
    /** @default "ok" */
    result: string;
    /** @default "collection" */
    response: string;
    data: UserSchema[];
    limit: number;
    offset: number;
    total: number;
}
/** UploadSession */
interface UploadSessionSchema {
    /** @format uuid */
    id: string;
    type: 'upload_session';
    attributes: UploadSessionAttributesSchema;
}
/** UploadSessionAttributes */
interface UploadSessionAttributesSchema {
    isCommitted: boolean;
    isProcessed: boolean;
    isDeleted: boolean;
    /** @min 1 */
    version: number;
    /** @format date-time */
    createdAt: Date;
    /** @format date-time */
    updatedAt: Date;
}
/** UploadSessionFile */
interface UploadSessionFileSchema {
    /** @format uuid */
    id: string;
    type: 'upload_session_file';
    attributes: UploadSessionFileAttributesSchema;
}
/** UploadSessionFileAttributes */
interface UploadSessionFileAttributesSchema {
    originalFileName: string;
    fileHash: string;
    fileSize: number;
    mimeType: string;
    source: 'local' | 'remote';
    /** @min 1 */
    version: number;
}
/** ChapterReadMarkersBatch */
type ChapterReadMarkerBatchSchema = {
    chapterIdsRead: string[];
    chapterIdsUnread: string[];
};
interface ChapterDraftSchema {
    /**
     * @maxLength 8
     * @pattern ^((0|[1-9]\d*)(\.\d+)?[a-z]?)?$
     */
    volume: string | null;
    /**
     * @maxLength 8
     * @pattern ^((0|[1-9]\d*)(\.\d+)?[a-z]?)?$
     */
    chapter: string | null;
    /** @maxLength 255 */
    title: string | null;
    /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
    translatedLanguage: string;
    /**
     * @maxLength 512
     * @pattern ^https?://
     */
    externalUrl?: string | null;
    /**
     * @format date-time
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    publishAt?: Date;
}
/**
 * ReferenceExpansionAuthor
 * Reference expansion options for author/artist entities or lists
 */
type ReferenceExpansionAuthorSchema = 'manga'[];
/**
 * ReferenceExpansionChapter
 * Reference expansion options for chapter entities or lists
 */
type ReferenceExpansionChapterSchema = ('manga' | 'scanlation_group' | 'user')[];
/**
 * ReferenceExpansionCoverArt
 * Reference expansion options for cover art entities or lists
 */
type ReferenceExpansionCoverArtSchema = ('manga' | 'user')[];
/**
 * ReferenceExpansionManga
 * Reference expansion options for manga entities or lists
 */
type ReferenceExpansionMangaSchema = ('manga' | 'cover_art' | 'author' | 'artist' | 'tag' | 'creator')[];
/**
 * ReferenceExpansionMangaRelation
 * Reference expansion options for manga relation entities or lists
 */
type ReferenceExpansionMangaRelationSchema = 'manga'[];
/**
 * ReferenceExpansionScanlationGroup
 * Reference expansion options for scanlation group entities or lists
 */
type ReferenceExpansionScanlationGroupSchema = ('leader' | 'member')[];
/**
 * StatisticsDetailsComments
 * Comments-related statistics of an entity.
 * If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
 */
type StatisticsDetailsCommentsSchema = {
    /**
     * The id of the thread backing the comments for that entity on the MangaDex Forums.
     * @min 1
     */
    threadId: number;
    /**
     * The number of replies on the MangaDex Forums thread backing this entity's comments. This excludes the initial comment that opens the thread, which is created by our systems.
     * @min 0
     */
    repliesCount: number;
} | null;
interface GetSearchMangaParamsSchema {
    /**
     * @min 0
     * @max 100
     * @default 10
     * @pattern ^\d+$
     */
    limit: number;
    /**
     * @min 0
     * @pattern ^\d+$
     */
    offset: number;
    title: string;
    /** @format uuid */
    authorOrArtist: string;
    authors: string[];
    artists: string[];
    /** Year of release or none */
    year: number | 'none';
    includedTags: string[];
    /** @default "AND" */
    includedTagsMode: 'AND' | 'OR';
    excludedTags: string[];
    /** @default "OR" */
    excludedTagsMode: 'AND' | 'OR';
    status: ('ongoing' | 'completed' | 'hiatus' | 'cancelled')[];
    originalLanguage: string[];
    excludedOriginalLanguage: string[];
    availableTranslatedLanguage: string[];
    publicationDemographic: ('shounen' | 'shoujo' | 'josei' | 'seinen' | 'none')[];
    /** Manga ids (limited to 100 per request) */
    ids: string[];
    /** @default ["safe","suggestive","erotica"] */
    contentRating: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    createdAtSince: string;
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    updatedAtSince: string;
    /** @default {"latestUploadedChapter":"desc"} */
    order: {
        title?: 'asc' | 'desc';
        year?: 'asc' | 'desc';
        createdAt?: 'asc' | 'desc';
        updatedAt?: 'asc' | 'desc';
        latestUploadedChapter?: 'asc' | 'desc';
        followedCount?: 'asc' | 'desc';
        relevance?: 'asc' | 'desc';
        rating?: 'asc' | 'desc';
    };
    /** Reference expansion options for manga entities or lists */
    includes: ReferenceExpansionMangaSchema;
    hasAvailableChapters: boolean;
    /** @format uuid */
    group: string;
}
interface GetSearchGroupParamsSchema {
    /**
     * @min 0
     * @max 100
     * @default 10
     */
    limit: number;
    /** @min 0 */
    offset: number;
    /** ScanlationGroup ids (limited to 100 per request) */
    ids: string[];
    name: string;
    focusedLanguage: string;
    /** Reference expansion options for scanlation group entities or lists */
    includes: ReferenceExpansionScanlationGroupSchema;
    /** @default {"latestUploadedChapter":"desc"} */
    order: {
        name?: 'asc' | 'desc';
        createdAt?: 'asc' | 'desc';
        updatedAt?: 'asc' | 'desc';
        followedCount?: 'asc' | 'desc';
        relevance?: 'asc' | 'desc';
    };
}
interface GetUserParamsSchema {
    /**
     * @min 0
     * @max 100
     * @default 10
     */
    limit: number;
    /** @min 0 */
    offset: number;
    /** User ids (limited to 100 per request) */
    ids: string[];
    username: string;
    order: {
        username?: 'asc' | 'desc';
    };
}
interface GetChapterParamsSchema {
    /**
     * @min 0
     * @max 100
     * @default 10
     */
    limit: number;
    /** @min 0 */
    offset: number;
    /** Chapter ids (limited to 100 per request) */
    ids: string[];
    title: string;
    groups: string[];
    uploader: string | string[];
    /** @format uuid */
    manga: string;
    volume: string | string[];
    chapter: string | string[];
    translatedLanguage: string[];
    originalLanguage: string[];
    excludedOriginalLanguage: string[];
    /** @default ["safe","suggestive","erotica"] */
    contentRating: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
    excludedGroups: string[];
    excludedUploaders: string[];
    /** @default "1" */
    includeFutureUpdates: '0' | '1';
    includeEmptyPages: 0 | 1;
    includeFuturePublishAt: 0 | 1;
    includeExternalUrl: 0 | 1;
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    createdAtSince: string;
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    updatedAtSince: string;
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    publishAtSince: string;
    order: {
        createdAt?: 'asc' | 'desc';
        updatedAt?: 'asc' | 'desc';
        publishAt?: 'asc' | 'desc';
        readableAt?: 'asc' | 'desc';
        volume?: 'asc' | 'desc';
        chapter?: 'asc' | 'desc';
    };
    includes: ('manga' | 'scanlation_group' | 'user')[];
}
interface GetListIdFeedParamsSchema {
    /**
     * @min 1
     * @max 500
     * @default 100
     */
    limit: number;
    /** @min 0 */
    offset: number;
    translatedLanguage: string[];
    originalLanguage: string[];
    excludedOriginalLanguage: string[];
    /** @default ["safe","suggestive","erotica"] */
    contentRating: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
    excludedGroups: string[];
    excludedUploaders: string[];
    /** @default "1" */
    includeFutureUpdates: '0' | '1';
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    createdAtSince: string;
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    updatedAtSince: string;
    /**
     * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
     * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
     */
    publishAtSince: string;
    order: {
        createdAt?: 'asc' | 'desc';
        updatedAt?: 'asc' | 'desc';
        publishAt?: 'asc' | 'desc';
        readableAt?: 'asc' | 'desc';
        volume?: 'asc' | 'desc';
        chapter?: 'asc' | 'desc';
    };
    /** Reference expansion options for chapter entities or lists */
    includes: ReferenceExpansionChapterSchema;
    includeEmptyPages: 0 | 1;
    includeFuturePublishAt: 0 | 1;
    includeExternalUrl: 0 | 1;
    /** @format uuid */
    id: string;
}
interface GetCoverParamsSchema {
    /**
     * @min 0
     * @max 100
     * @default 10
     */
    limit: number;
    /** @min 0 */
    offset: number;
    /** Manga ids (limited to 100 per request) */
    manga: string[];
    /** Covers ids (limited to 100 per request) */
    ids: string[];
    /** User ids (limited to 100 per request) */
    uploaders: string[];
    /** Locales of cover art (limited to 100 per request) */
    locales: string[];
    order: {
        createdAt?: 'asc' | 'desc';
        updatedAt?: 'asc' | 'desc';
        volume?: 'asc' | 'desc';
    };
    /** Reference expansion options for cover art entities or lists */
    includes: ReferenceExpansionCoverArtSchema;
}
interface GetAuthorParamsSchema {
    /**
     * @min 0
     * @max 100
     * @default 10
     */
    limit: number;
    /** @min 0 */
    offset: number;
    /** Author ids (limited to 100 per request) */
    ids: string[];
    name: string;
    order: {
        name?: 'asc' | 'desc';
    };
    /** Reference expansion options for author/artist entities or lists */
    includes: ReferenceExpansionAuthorSchema;
}
interface GetMangaRandomParamsSchema {
    /** Reference expansion options for manga entities or lists */
    includes: ReferenceExpansionMangaSchema;
    /** @default ["safe","suggestive","erotica"] */
    contentRating: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
    includedTags: string[];
    /** @default "AND" */
    includedTagsMode: 'AND' | 'OR';
    excludedTags: string[];
    /** @default "OR" */
    excludedTagsMode: 'AND' | 'OR';
}
interface GetMangaDraftsParamsSchema {
    /**
     * @min 1
     * @max 100
     * @default 10
     */
    limit: number;
    /** @min 0 */
    offset: number;
    state: 'draft' | 'submitted' | 'rejected';
    /** @default {"createdAt":"desc"} */
    order: {
        title?: 'asc' | 'desc';
        year?: 'asc' | 'desc';
        createdAt?: 'asc' | 'desc';
        updatedAt?: 'asc' | 'desc';
    };
    /** Reference expansion options for manga entities or lists */
    includes: ReferenceExpansionMangaSchema;
}
declare namespace Manga$1 {
    /**
     * @description Search a list of Manga.
     * @tags Manga
     * @name GetSearchManga
     * @summary Manga list
     * @request GET:/manga
     */
    namespace GetSearchManga {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 0
             * @max 100
             * @default 10
             * @pattern ^\d+$
             */
            limit?: number;
            /**
             * @min 0
             * @pattern ^\d+$
             */
            offset?: number;
            title?: string;
            /** @format uuid */
            authorOrArtist?: string;
            authors?: string[];
            artists?: string[];
            /** Year of release or none */
            year?: number | 'none';
            includedTags?: string[];
            /** @default "AND" */
            includedTagsMode?: 'AND' | 'OR';
            excludedTags?: string[];
            /** @default "OR" */
            excludedTagsMode?: 'AND' | 'OR';
            status?: ('ongoing' | 'completed' | 'hiatus' | 'cancelled')[];
            originalLanguage?: string[];
            excludedOriginalLanguage?: string[];
            availableTranslatedLanguage?: string[];
            publicationDemographic?: ('shounen' | 'shoujo' | 'josei' | 'seinen' | 'none')[];
            /** Manga ids (limited to 100 per request) */
            ids?: string[];
            /** @default ["safe","suggestive","erotica"] */
            contentRating?: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            createdAtSince?: string;
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            updatedAtSince?: string;
            /** @default {"latestUploadedChapter":"desc"} */
            order?: {
                title?: 'asc' | 'desc';
                year?: 'asc' | 'desc';
                createdAt?: 'asc' | 'desc';
                updatedAt?: 'asc' | 'desc';
                latestUploadedChapter?: 'asc' | 'desc';
                followedCount?: 'asc' | 'desc';
                relevance?: 'asc' | 'desc';
                rating?: 'asc' | 'desc';
            };
            /** Reference expansion options for manga entities or lists */
            includes?: ReferenceExpansionMangaSchema;
            hasAvailableChapters?: '0' | '1' | 'true' | 'false';
            /** @format uuid */
            group?: string;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = MangaListSchema;
    }
    /**
     * @description Create a new Manga.
     * @tags Manga
     * @name PostManga
     * @summary Create Manga
     * @request POST:/manga
     * @secure
     */
    namespace PostManga {
        type RequestParams = {};
        type RequestQuery = {};
        type RequestBody = MangaCreateSchema;
        type RequestHeaders = {
            /** @default "application/json" */
            'Content-Type': string;
        };
        type ResponseBody = MangaResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaAggregate
     * @summary Get Manga volumes & chapters
     * @request GET:/manga/{id}/aggregate
     */
    namespace GetMangaAggregate {
        type RequestParams = {
            /**
             * Manga ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {
            translatedLanguage?: string[];
            groups?: string[];
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            volumes?: Record<string, {
                volume?: string;
                count?: number;
                chapters?: Record<string, {
                    chapter?: string;
                    /** @format uuid */
                    id?: string;
                    others?: string[];
                    count?: number;
                }>;
            }>;
        };
    }
    /**
     * @description Get Manga.
     * @tags Manga
     * @name GetMangaId
     * @summary Get Manga
     * @request GET:/manga/{id}
     */
    namespace GetMangaId {
        type RequestParams = {
            /**
             * Manga ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {
            /** Reference expansion options for manga entities or lists */
            includes?: ReferenceExpansionMangaSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = MangaResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name PutMangaId
     * @summary Update Manga
     * @request PUT:/manga/{id}
     * @secure
     */
    namespace PutMangaId {
        type RequestParams = {
            /**
             * Manga ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = MangaEditSchema & {
            artists?: string[];
            authors?: string[];
        };
        type RequestHeaders = {
            /** @default "application/json" */
            'Content-Type': string;
        };
        type ResponseBody = MangaResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name DeleteMangaId
     * @summary Delete Manga
     * @request DELETE:/manga/{id}
     * @secure
     */
    namespace DeleteMangaId {
        type RequestParams = {
            /**
             * Manga ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags CustomList
     * @name PostMangaIdListListId
     * @summary Add Manga in CustomList
     * @request POST:/manga/{id}/list/{listId}
     * @secure
     */
    namespace PostMangaIdListListId {
        type RequestParams = {
            /**
             * Manga ID
             * @format uuid
             */
            id: string;
            /**
             * CustomList ID
             * @format uuid
             */
            listId: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags CustomList
     * @name DeleteMangaIdListListId
     * @summary Remove Manga in CustomList
     * @request DELETE:/manga/{id}/list/{listId}
     * @secure
     */
    namespace DeleteMangaIdListListId {
        type RequestParams = {
            /**
             * Manga ID
             * @format uuid
             */
            id: string;
            /**
             * CustomList ID
             * @format uuid
             */
            listId: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name DeleteMangaIdFollow
     * @summary Unfollow Manga
     * @request DELETE:/manga/{id}/follow
     * @secure
     */
    namespace DeleteMangaIdFollow {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name PostMangaIdFollow
     * @summary Follow Manga
     * @request POST:/manga/{id}/follow
     * @secure
     */
    namespace PostMangaIdFollow {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaIdFeed
     * @summary Manga feed
     * @request GET:/manga/{id}/feed
     */
    namespace GetMangaIdFeed {
        type RequestParams = {
            /**
             * Manga ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {
            /**
             * @min 1
             * @max 500
             * @default 100
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
            translatedLanguage?: string[];
            originalLanguage?: string[];
            excludedOriginalLanguage?: string[];
            /** @default ["safe","suggestive","erotica"] */
            contentRating?: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
            excludedGroups?: string[];
            excludedUploaders?: string[];
            /** @default "1" */
            includeFutureUpdates?: '0' | '1';
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            createdAtSince?: string;
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            updatedAtSince?: string;
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            publishAtSince?: string;
            order?: {
                createdAt?: 'asc' | 'desc';
                updatedAt?: 'asc' | 'desc';
                publishAt?: 'asc' | 'desc';
                readableAt?: 'asc' | 'desc';
                volume?: 'asc' | 'desc';
                chapter?: 'asc' | 'desc';
            };
            /** Reference expansion options for chapter entities or lists */
            includes?: ReferenceExpansionChapterSchema;
            includeEmptyPages?: 0 | 1;
            includeFuturePublishAt?: 0 | 1;
            includeExternalUrl?: 0 | 1;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ChapterListSchema;
    }
    /**
     * @description A list of chapter ids that are marked as read for the specified manga
     * @tags ReadMarker
     * @name GetMangaChapterReadmarkers
     * @summary Manga read markers
     * @request GET:/manga/{id}/read
     * @secure
     */
    namespace GetMangaChapterReadmarkers {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            result?: 'ok';
            data?: string[];
        };
    }
    /**
     * @description Send a lot of chapter ids for one manga to mark as read and/or unread
     * @tags ReadMarker
     * @name PostMangaChapterReadmarkers
     * @summary Manga read markers batch
     * @request POST:/manga/{id}/read
     * @secure
     */
    namespace PostMangaChapterReadmarkers {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {
            /** Adding this will cause the chapter to be stored in the user's reading history */
            updateHistory?: boolean;
        };
        type RequestBody = ChapterReadMarkerBatchSchema;
        type RequestHeaders = {};
        type ResponseBody = {
            result?: 'ok';
        };
    }
    /**
     * @description A list of chapter ids that are marked as read for the given manga ids
     * @tags ReadMarker
     * @name GetMangaChapterReadmarkers2
     * @summary Manga read markers
     * @request GET:/manga/read
     * @secure
     */
    namespace GetMangaChapterReadmarkers2 {
        type RequestParams = {};
        type RequestQuery = {
            /** Manga ids */
            ids: string[];
            /** Group results by manga ids */
            grouped?: boolean;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            result?: 'ok';
            data?: string[] | Record<string, string[]>;
        };
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaRandom
     * @summary Get a random Manga
     * @request GET:/manga/random
     */
    namespace GetMangaRandom {
        type RequestParams = {};
        type RequestQuery = {
            /** Reference expansion options for manga entities or lists */
            includes?: ReferenceExpansionMangaSchema;
            /** @default ["safe","suggestive","erotica"] */
            contentRating?: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
            includedTags?: string[];
            /** @default "AND" */
            includedTagsMode?: 'AND' | 'OR';
            excludedTags?: string[];
            /** @default "OR" */
            excludedTagsMode?: 'AND' | 'OR';
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = MangaResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaTag
     * @summary Tag list
     * @request GET:/manga/tag
     */
    namespace GetMangaTag {
        type RequestParams = {};
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = TagResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaStatus
     * @summary Get all Manga reading status for logged User
     * @request GET:/manga/status
     * @secure
     */
    namespace GetMangaStatus {
        type RequestParams = {};
        type RequestQuery = {
            /** Used to filter the list by given status */
            status?: 'reading' | 'on_hold' | 'plan_to_read' | 'dropped' | 're_reading' | 'completed';
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            statuses?: Record<string, 'reading' | 'on_hold' | 'plan_to_read' | 'dropped' | 're_reading' | 'completed'>;
        };
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaIdStatus
     * @summary Get a Manga reading status
     * @request GET:/manga/{id}/status
     * @secure
     */
    namespace GetMangaIdStatus {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            status?: 'reading' | 'on_hold' | 'plan_to_read' | 'dropped' | 're_reading' | 'completed';
        };
    }
    /**
     * No description
     * @tags Manga
     * @name PostMangaIdStatus
     * @summary Update Manga reading status
     * @request POST:/manga/{id}/status
     * @secure
     */
    namespace PostMangaIdStatus {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = UpdateMangaStatusSchema;
        type RequestHeaders = {
            /** @default "application/json" */
            'Content-Type': string;
        };
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaIdDraft
     * @summary Get a specific Manga Draft
     * @request GET:/manga/draft/{id}
     * @secure
     */
    namespace GetMangaIdDraft {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {
            /** Reference expansion options for manga entities or lists */
            includes?: ReferenceExpansionMangaSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = MangaResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name CommitMangaDraft
     * @summary Submit a Manga Draft
     * @request POST:/manga/draft/{id}/commit
     * @secure
     */
    namespace CommitMangaDraft {
        type RequestParams = {
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = {
            /** @min 1 */
            version?: number;
        };
        type RequestHeaders = {};
        type ResponseBody = MangaResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaDrafts
     * @summary Get a list of Manga Drafts
     * @request GET:/manga/draft
     * @secure
     */
    namespace GetMangaDrafts {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 1
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
            state?: 'draft' | 'submitted' | 'rejected';
            /** @default {"createdAt":"desc"} */
            order?: {
                title?: 'asc' | 'desc';
                year?: 'asc' | 'desc';
                createdAt?: 'asc' | 'desc';
                updatedAt?: 'asc' | 'desc';
            };
            /** Reference expansion options for manga entities or lists */
            includes?: ReferenceExpansionMangaSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = MangaResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name GetMangaRelation
     * @summary Manga relation list
     * @request GET:/manga/{mangaId}/relation
     */
    namespace GetMangaRelation {
        type RequestParams = {
            /** @format uuid */
            mangaId: string;
        };
        type RequestQuery = {
            /** Reference expansion options for manga relation entities or lists */
            includes?: ReferenceExpansionMangaRelationSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = MangaRelationListSchema;
    }
    /**
     * @description Create a new Manga relation.
     * @tags Manga
     * @name PostMangaRelation
     * @summary Create Manga relation
     * @request POST:/manga/{mangaId}/relation
     * @secure
     */
    namespace PostMangaRelation {
        type RequestParams = {
            /** @format uuid */
            mangaId: string;
        };
        type RequestQuery = {};
        type RequestBody = MangaRelationCreateSchema;
        type RequestHeaders = {
            /** @default "application/json" */
            'Content-Type': string;
        };
        type ResponseBody = MangaRelationResponseSchema;
    }
    /**
     * No description
     * @tags Manga
     * @name DeleteMangaRelationId
     * @summary Delete Manga relation
     * @request DELETE:/manga/{mangaId}/relation/{id}
     * @secure
     */
    namespace DeleteMangaRelationId {
        type RequestParams = {
            /** @format uuid */
            mangaId: string;
            /** @format uuid */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
}
declare namespace User$1 {
    /**
     * @description This will list public and private CustomList
     * @tags CustomList
     * @name GetUserList
     * @summary Get logged User CustomList list
     * @request GET:/user/list
     * @secure
     */
    namespace GetUserList {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 0
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = CustomListListSchema;
    }
    /**
     * @description This will list only public CustomList
     * @tags CustomList
     * @name GetUserIdList
     * @summary Get User's CustomList list
     * @request GET:/user/{id}/list
     */
    namespace GetUserIdList {
        type RequestParams = {
            /**
             * User ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {
            /**
             * @min 0
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = CustomListListSchema;
    }
    /**
     * No description
     * @tags User
     * @name GetUser
     * @summary User list
     * @request GET:/user
     * @secure
     */
    namespace GetUser {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 0
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
            /** User ids (limited to 100 per request) */
            ids?: string[];
            username?: string;
            order?: {
                username?: 'asc' | 'desc';
            };
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = UserListSchema;
    }
    /**
     * No description
     * @tags User
     * @name GetUserId
     * @summary Get User
     * @request GET:/user/{id}
     */
    namespace GetUserId {
        type RequestParams = {
            /**
             * User ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = UserResponseSchema;
    }
    /**
     * No description
     * @tags User
     * @name DeleteUserId
     * @summary Delete User
     * @request DELETE:/user/{id}
     * @deprecated
     * @secure
     */
    namespace DeleteUserId {
        type RequestParams = {
            /**
             * User ID
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags User
     * @name PostUserDeleteCode
     * @summary Approve User deletion
     * @request POST:/user/delete/{code}
     * @deprecated
     */
    namespace PostUserDeleteCode {
        type RequestParams = {
            /**
             * User delete code
             * @format uuid
             */
            code: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Feed
     * @name GetUserFollowsMangaFeed
     * @summary Get logged User followed Manga feed (Chapter list)
     * @request GET:/user/follows/manga/feed
     * @secure
     */
    namespace GetUserFollowsMangaFeed {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 1
             * @max 500
             * @default 100
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
            translatedLanguage?: string[];
            originalLanguage?: string[];
            excludedOriginalLanguage?: string[];
            /** @default ["safe","suggestive","erotica"] */
            contentRating?: ('safe' | 'suggestive' | 'erotica' | 'pornographic')[];
            excludedGroups?: string[];
            excludedUploaders?: string[];
            /** @default "1" */
            includeFutureUpdates?: '0' | '1';
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            createdAtSince?: string;
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            updatedAtSince?: string;
            /**
             * DateTime string with following format: YYYY-MM-DDTHH:MM:SS in timezone UTC+0
             * @pattern ^\d{4}-[0-1]\d-([0-2]\d|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d$
             */
            publishAtSince?: string;
            order?: {
                createdAt?: 'asc' | 'desc';
                updatedAt?: 'asc' | 'desc';
                publishAt?: 'asc' | 'desc';
                readableAt?: 'asc' | 'desc';
                volume?: 'asc' | 'desc';
                chapter?: 'asc' | 'desc';
            };
            /** Reference expansion options for chapter entities or lists */
            includes?: ReferenceExpansionChapterSchema;
            includeEmptyPages?: 0 | 1;
            includeFuturePublishAt?: 0 | 1;
            includeExternalUrl?: 0 | 1;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ChapterListSchema;
    }
    /**
     * No description
     * @tags User
     * @name GetUserMe
     * @summary Logged User details
     * @request GET:/user/me
     * @secure
     */
    namespace GetUserMe {
        type RequestParams = {};
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = UserResponseSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsGroup
     * @summary Get logged User followed Groups
     * @request GET:/user/follows/group
     * @secure
     */
    namespace GetUserFollowsGroup {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 1
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
            /** Reference expansion options for scanlation group entities or lists */
            includes?: ReferenceExpansionScanlationGroupSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ScanlationGroupListSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsGroupId
     * @summary Check if logged User follows a Group
     * @request GET:/user/follows/group/{id}
     * @secure
     */
    namespace GetUserFollowsGroupId {
        type RequestParams = {
            /**
             * Scanlation Group id
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsUser
     * @summary Get logged User followed User list
     * @request GET:/user/follows/user
     * @secure
     */
    namespace GetUserFollowsUser {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 1
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = UserListSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsUserId
     * @summary Check if logged User follows a User
     * @request GET:/user/follows/user/{id}
     * @secure
     */
    namespace GetUserFollowsUserId {
        type RequestParams = {
            /**
             * User id
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsManga
     * @summary Get logged User followed Manga list
     * @request GET:/user/follows/manga
     * @secure
     */
    namespace GetUserFollowsManga {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 1
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
            /** Reference expansion options for manga entities or lists */
            includes?: ReferenceExpansionMangaSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = MangaListSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsMangaId
     * @summary Check if logged User follows a Manga
     * @request GET:/user/follows/manga/{id}
     * @secure
     */
    namespace GetUserFollowsMangaId {
        type RequestParams = {
            /**
             * Manga id
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsList
     * @summary Get logged User followed CustomList list
     * @request GET:/user/follows/list
     * @secure
     */
    namespace GetUserFollowsList {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 1
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = CustomListListSchema;
    }
    /**
     * No description
     * @tags Follows
     * @name GetUserFollowsListId
     * @summary Check if logged User follows a CustomList
     * @request GET:/user/follows/list/{id}
     * @secure
     */
    namespace GetUserFollowsListId {
        type RequestParams = {
            /**
             * CustomList id
             * @format uuid
             */
            id: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
    /**
     * No description
     * @tags ReadMarker
     * @name GetReadingHistory
     * @summary Get users reading history
     * @request GET:/user/history
     * @secure
     */
    namespace GetReadingHistory {
        type RequestParams = {};
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            ratings?: {
                chapterId?: string;
                /** @format date-time */
                readDate?: Date;
            }[];
        };
    }
}
declare namespace Cover$1 {
    /**
     * No description
     * @tags Cover
     * @name GetCover
     * @summary CoverArt list
     * @request GET:/cover
     */
    namespace GetCover {
        type RequestParams = {};
        type RequestQuery = {
            /**
             * @min 0
             * @max 100
             * @default 10
             */
            limit?: number;
            /** @min 0 */
            offset?: number;
            /** Manga ids (limited to 100 per request) */
            manga?: string[];
            /** Covers ids (limited to 100 per request) */
            ids?: string[];
            /** User ids (limited to 100 per request) */
            uploaders?: string[];
            /** Locales of cover art (limited to 100 per request) */
            locales?: string[];
            order?: {
                createdAt?: 'asc' | 'desc';
                updatedAt?: 'asc' | 'desc';
                volume?: 'asc' | 'desc';
            };
            /** Reference expansion options for cover art entities or lists */
            includes?: ReferenceExpansionCoverArtSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = CoverListSchema;
    }
    /**
     * No description
     * @tags Cover
     * @name UploadCover
     * @summary Upload Cover
     * @request POST:/cover/{mangaOrCoverId}
     * @secure
     */
    namespace UploadCover {
        type RequestParams = {
            /**
             * Is Manga UUID on POST
             * @format uuid
             */
            mangaOrCoverId: string;
        };
        type RequestQuery = {};
        type RequestBody = {
            /** @format binary */
            file?: File;
            /**
             * @maxLength 8
             * @pattern ^(0|[1-9]\\d*)((\\.\\d+){1,2})?[a-z]?$
             */
            volume?: string | null;
            description?: string;
            /** @pattern ^[a-z]{2}(-[a-z]{2})?$ */
            locale?: string;
        };
        type RequestHeaders = {
            /** @default "multipart/form-data" */
            'Content-Type': string;
        };
        type ResponseBody = CoverResponseSchema;
    }
    /**
     * No description
     * @tags Cover
     * @name GetCoverId
     * @summary Get Cover
     * @request GET:/cover/{mangaOrCoverId}
     */
    namespace GetCoverId {
        type RequestParams = {
            /**
             * Is Manga UUID on POST
             * @format uuid
             */
            mangaOrCoverId: string;
        };
        type RequestQuery = {
            /** Reference expansion options for cover art entities or lists */
            includes?: ReferenceExpansionCoverArtSchema;
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = CoverResponseSchema;
    }
    /**
     * No description
     * @tags Cover
     * @name EditCover
     * @summary Edit Cover
     * @request PUT:/cover/{mangaOrCoverId}
     * @secure
     */
    namespace EditCover {
        type RequestParams = {
            /**
             * Is Manga UUID on POST
             * @format uuid
             */
            mangaOrCoverId: string;
        };
        type RequestQuery = {};
        type RequestBody = CoverEditSchema;
        type RequestHeaders = {
            /** @default "application/json" */
            'Content-Type': string;
        };
        type ResponseBody = CoverResponseSchema;
    }
    /**
     * No description
     * @tags Cover
     * @name DeleteCover
     * @summary Delete Cover
     * @request DELETE:/cover/{mangaOrCoverId}
     * @secure
     */
    namespace DeleteCover {
        type RequestParams = {
            /**
             * Is Manga UUID on POST
             * @format uuid
             */
            mangaOrCoverId: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = ResponseSchema;
    }
}
declare namespace Statistics {
    /**
     * No description
     * @tags Statistics
     * @name GetStatisticsChapterUuid
     * @summary Get statistics about given chapter
     * @request GET:/statistics/chapter/{uuid}
     * @secure
     */
    namespace GetStatisticsChapterUuid {
        type RequestParams = {
            /** @format uuid */
            uuid: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            statistics?: Record<string, {
                /**
                 * Comments-related statistics of an entity.
                 * If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
                 */
                comments?: StatisticsDetailsCommentsSchema;
            }>;
        };
    }
    /**
     * No description
     * @tags Statistics
     * @name GetStatisticsChapters
     * @summary Get statistics about given chapters
     * @request GET:/statistics/chapter
     * @secure
     */
    namespace GetStatisticsChapters {
        type RequestParams = {};
        type RequestQuery = {
            chapter: string[];
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            statistics?: Record<string, {
                /**
                 * Comments-related statistics of an entity.
                 * If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
                 */
                comments?: StatisticsDetailsCommentsSchema;
            }>;
        };
    }
    /**
     * No description
     * @tags Statistics
     * @name GetStatisticsGroupUuid
     * @summary Get statistics about given scanlation group
     * @request GET:/statistics/group/{uuid}
     * @secure
     */
    namespace GetStatisticsGroupUuid {
        type RequestParams = {
            /** @format uuid */
            uuid: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            statistics?: Record<string, {
                /**
                 * Comments-related statistics of an entity.
                 * If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
                 */
                comments?: StatisticsDetailsCommentsSchema;
            }>;
        };
    }
    /**
     * No description
     * @tags Statistics
     * @name GetStatisticsGroups
     * @summary Get statistics about given groups
     * @request GET:/statistics/group
     * @secure
     */
    namespace GetStatisticsGroups {
        type RequestParams = {};
        type RequestQuery = {
            group: string[];
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            statistics?: Record<string, {
                /**
                 * Comments-related statistics of an entity.
                 * If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
                 */
                comments?: StatisticsDetailsCommentsSchema;
            }>;
        };
    }
    /**
     * No description
     * @tags Statistics
     * @name GetStatisticsMangaUuid
     * @summary Get statistics about given Manga
     * @request GET:/statistics/manga/{uuid}
     * @secure
     */
    namespace GetStatisticsMangaUuid {
        type RequestParams = {
            /** @format uuid */
            uuid: string;
        };
        type RequestQuery = {};
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            statistics?: Record<string, {
                /**
                 * Comments-related statistics of an entity.
                 * If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
                 */
                comments?: StatisticsDetailsCommentsSchema;
                rating?: {
                    /** Will be nullable if no ratings has been given */
                    average?: number | null;
                    /** Average weighted on all the Manga population */
                    bayesian?: number;
                    distribution?: {
                        '1'?: number;
                        '2'?: number;
                        '3'?: number;
                        '4'?: number;
                        '5'?: number;
                        '6'?: number;
                        '7'?: number;
                        '8'?: number;
                        '9'?: number;
                        '10'?: number;
                    };
                };
                follows?: number;
            }>;
        };
    }
    /**
     * No description
     * @tags Statistics
     * @name GetStatisticsManga
     * @summary Find statistics about given Manga
     * @request GET:/statistics/manga
     * @secure
     */
    namespace GetStatisticsManga {
        type RequestParams = {};
        type RequestQuery = {
            manga: string[];
        };
        type RequestBody = never;
        type RequestHeaders = {};
        type ResponseBody = {
            /** @default "ok" */
            result?: string;
            statistics?: Record<string, {
                /**
                 * Comments-related statistics of an entity.
                 * If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
                 */
                comments?: StatisticsDetailsCommentsSchema;
                rating?: {
                    /** Will be nullable if no ratings has been done */
                    average?: number | null;
                    /** Average weighted on all the Manga population */
                    bayesian?: number;
                };
                follows?: number;
            }>;
        };
    }
}

/**
 * This class represents the most abstract version of a MangaDex object, containing
 * only the ID of the object. This is mostly used for instanceOf checks.
 * @internal
 */
declare abstract class IDObject {
    abstract id: string;
}

type GettableClass<T> = Function & {
    get: (id: string) => Promise<T>;
    getMultiple?: (ids: string[]) => Promise<T[]>;
};
type PartialRelationshipSchema = Pick<RelationshipSchema, 'id' | 'type'> & Partial<Pick<RelationshipSchema, 'related' | 'attributes'>>;
/**
 * Represents a relationship from one MangaDex object to another such as a manga, author, etc via its id.
 */
declare class Relationship<T> extends IDObject {
    /**
     * The MangaDex UUID of the object this relationship refers to
     */
    id: string;
    /**
     * What type of object is this a relationship to
     */
    type: string;
    /**
     * If the relationship is between two manga, how are they related?
     */
    related?: RelationshipSchema['related'];
    /**
     * Cached relationships are created by using the 'includes' parameter on search requests or
     * other functions that support it. For every type included in the parameter, relationships of
     * that type will be replaced by the actual object. The object will still be represented
     * by a Relationship object, but the {@link resolve} method will return instantly with the cached data.
     * Each resulting object will have no further relationships of its own.
     */
    cached: boolean;
    private cachedData?;
    private static typeMap;
    private static typeMapLocked;
    constructor(data: PartialRelationshipSchema);
    /**
     * This will automatically fetch the associated object that this relationship refers to.
     * In other words, it wil call Manga.get(id), Chapter.get(id), etc with the information
     * stored in this relationship instance. If this relationship is cached, then the resulting
     * object will not have any relationships of its own.
     */
    resolve(): Promise<T>;
    /**
     * This will {@link Relationship.resolve} an array of relationships, returning another array
     * in the same order.
     * @param relationshipArray - An array of relationships of the same type
     */
    static resolveAll<T>(relationshipArray: Relationship<T>[]): Promise<T[]>;
    /**
     * This will search through a relationship response from MangaDex and convert any
     * relationships of a specific type into relationship objects.
     * @internal
     */
    static convertType<T2>(type: string, arr: RelationshipSchema[]): Relationship<T2>[];
    /**
     * This function is used to resolved circular references, and should only be used in base.ts.
     * Specifically, it pairs a relationship type to its associated class.
     * @internal
     */
    static registerTypes(types: string[], classObj: GettableClass<unknown>): void;
    /**
     * Lock the type map so that no more types can be registered.
     * @internal
     */
    static lockTypeMap(): void;
    /**
     * Returns an array of all registered Relationship types
     * @internal
     */
    static getRegisteredTypes(): string[];
}

/**
 * This class represents a map of locales and their associated strings.
 * Each string can be accessed by using the locale as the key (e.g. 'en', 'jp').
 * {@link localString} and {@link setGlobalLocale} can be used to
 * automatically access a preferred locale.
 * @example
 * var locStr;
 * locStr['en']; // English String
 * LocalizedString.setGlobalLocale('jp');
 * locStr.localString; // Japanese String
 */
declare class LocalizedString implements LocalizedStringSchema {
    private static globalLocale;
    [x: string]: string;
    constructor(strings: LocalizedStringSchema);
    /**
     * The string associated with the current global locale (set with setGlobalLocale()).
     * If the global locale is not available for this string, the English string is returned.
     * If that is also unavailable, the next available locale is returned. If no locales are
     * available, an empty string is returned.
     */
    get localString(): string;
    /**
     * This function sets the default locale used by {@link LocalizedString.localString}.
     */
    static setGlobalLocale(locale: string): void;
}

/**
 * This class represents a genre tag for a manga
 */
declare class Tag extends IDObject implements TagAttributesSchema {
    private static allTagCache;
    /**
     * MangaDex UUID of this tag
     */
    id: string;
    /**
     * Localized names for this tag
     */
    name: LocalizedString;
    /**
     * Localized descriptions for this tag
     */
    description: LocalizedString;
    /**
     * The tag group this tag belongs to
     */
    group: 'content' | 'format' | 'genre' | 'theme';
    /**
     * The version of this tag (incremented whenever the tag's data is updated)
     */
    version: number;
    constructor(data: TagSchema);
    /**
     * Get the localString from the name {@link LocalizedString} object
     */
    get localName(): string;
    /**
     * Get the localString from the description {@link LocalizedString} object
     */
    get localDescription(): string;
    /**
     * Retrieves every tag used on MangaDex. The result is cached so any promise
     * after the first will resolve instantly.
     */
    static getAllTags(): Promise<Tag[]>;
    /**
     * Return the first tag that contains the specified name
     */
    static getByName(name: string): Promise<Tag>;
    /**
     * Return tags with the associated names
     */
    static getByNames(names: string[]): Promise<Tag[]>;
}

/**
 * A simple record object representing links to manga on different websites.
 * Websites are the keys, and the values are full urls (when available).
 */
declare class Links {
    /**
     * Anilist (https://anilist.co) link to manga
     */
    anilist?: string;
    /**
     * AnimePlanet (https://anime-planet.com) link to manga
     */
    animePlanet?: string;
    /**
     * Bookwalker (https://bookwalker.jp/) link to manga
     */
    bookWalker?: string;
    /**
     * Mangaupdates (https://mangaupdates.com) link to manga
     */
    mangaUpdates?: string;
    /**
     * Novelupdates (https://novelupdates.com) link to manga
     */
    novelUpdates?: string;
    /**
     * MyAnimeList (https://myanimelist.net) link to manga
     */
    myAnimeList?: string;
    /**
     * Kitsu (https://kitsu.io) link to manga
     */
    kitsu?: string;
    /**
     * Amazon (https://amazon.com) link to manga
     */
    amazon?: string;
    /**
     * EBookJapan (https://ebookjapan.yahoo.co.jp) link to manga
     */
    eBookJapan?: string;
    /**
     * Link to manga raws
     */
    raw?: string;
    /**
     * Link to offical english manga translation
     */
    officialEnglishTranslation?: string;
    /**
     * CDJapan (https://www.cdjapan.co.jp/) link to manga
     */
    cdJapan?: string;
    constructor(linksObject?: Record<string, string>);
}

type CommonKeys<T1, T2> = keyof T1 & keyof T2;
type IntersectingProps<T1, T2> = {
    [x in CommonKeys<T1, T2>]: T1[x] | T2[x];
};
/**
 * Merges two types, creating a union at every shared property.
 */
type Merge<T1, T2> = Omit<T1, CommonKeys<T1, T2>> & IntersectingProps<T1, T2> & Omit<T2, CommonKeys<T1, T2>>;
type DeepRequire<T> = Required<{
    [P in keyof T]: T[P] extends object | undefined ? DeepRequire<Required<T[P]>> : T[P];
}>;
interface IAuthClient {
    getSessionToken: () => Promise<string>;
}

type GroupSearchParams = Partial<Merge<GetSearchGroupParamsSchema, {
    ids: Group[];
}>>;
type GroupStatsResponse = DeepRequire<Statistics.GetStatisticsGroups.ResponseBody>;
type GroupStats = GroupStatsResponse['statistics'][string];
type FollowedGroupsParams = User$1.GetUserFollowsGroup.RequestQuery;
declare class Group extends IDObject implements ScanlationGroupAttributesSchema {
    /**
     * The MangaDex UUID of this group
     */
    id: string;
    /**
     * The name of this group
     */
    name: string;
    /**
     * Alternate names for this group, including localized names
     */
    altNames: LocalizedString[];
    /**
     * Url to this group's website
     */
    website: string | null;
    /**
     * IRC server of this group
     */
    ircServer: string | null;
    /**
     * IRC channel of this group
     */
    ircChannel: string | null;
    /**
     * Discord server of this group
     */
    discord: string | null;
    /**
     * Email of this group
     */
    contactEmail: string | null;
    /**
     * Description of this group (not localized)
     */
    description: string | null;
    /**
     * Twitter profile of this group
     */
    twitter: string | null;
    /**
     * MangaUpdates profile of this group
     */
    mangaUpdates: string | null;
    /**
     * Languages this group focusses on translating
     */
    focusedLanguage: string[] | null;
    /**
     * Is this group locked from uploading?
     */
    locked: boolean;
    /**
     * Is this an official scanlation group?
     */
    official: boolean;
    /**
     * Is this group inactive?
     */
    inactive: boolean;
    /**
     * The delay between when this group uploads a chapter and when that chapter becomes readable
     */
    publishDelay: string;
    /**
     * The version of this group (incremented by updating the group data)
     */
    version: number;
    /**
     * When this group was created
     */
    createdAt: Date;
    /**
     * When this group was last updated
     */
    updatedAt: Date;
    /**
     * Relationship to the user profile of the user
     */
    leader: Relationship<User> | null;
    /**
     * Array of relationships to the member users of this group
     */
    members: Relationship<User>[];
    /**
     * Is this group ex-licensed?
     */
    exLicensed: boolean;
    /**
     * Is this group verified?
     */
    verified: boolean;
    constructor(schem: ScanlationGroupSchema);
    /**
     * Retrieves a group by their id
     */
    static get(id: string): Promise<Group>;
    /**
     * Retrieves a list of groups according to the specified search parameters
     */
    static search(query?: GroupSearchParams): Promise<Group[]>;
    /**
     * Retrieves an array of groups by an array of ids
     */
    static getMultiple(ids: string[]): Promise<Group[]>;
    /**
     * Performs a search for a group and returns the first one found. If no results are
     * found, null is returned
     */
    static getByQuery(query?: GroupSearchParams): Promise<Group | null>;
    /**
     * Create a new group
     */
    static create(data: CreateScanlationGroupSchema): Promise<Group>;
    /**
     * Deletes a group by their id
     */
    static delete(id: string): Promise<void>;
    /**
     * Deletes this group
     */
    delete(): Promise<void>;
    /**
     * Updates a group's information.
     */
    update(data: Omit<CreateScanlationGroupSchema, 'version'>): Promise<Group>;
    /**
     * Makes the logged in user follow or unfollow a group
     */
    static changeFollowship(id: string, follow?: boolean): Promise<void>;
    /**
     * Makes the user follow or unfollow this group
     */
    changeFollowship(follow?: boolean): Promise<void>;
    /**
     * Gets the statistics about a list of groups
     */
    static getStatistics(ids: string[] | Group[]): Promise<Record<string, GroupStats>>;
    /**
     * Gets the statistics about this group
     */
    getStatistics(): Promise<GroupStats>;
    /**
     * Gets an array of groups that the current user follows
     */
    static getFollowedGroups(query?: FollowedGroupsParams): Promise<Group[]>;
}

type UserSearchParams = Partial<Merge<GetUserParamsSchema, {
    ids: User[];
}>>;
type FollowedUserParams = User$1.GetUserFollowsUser.RequestQuery;
/**
 * This class represents a MangaDex user such as a chapter uploader
 */
declare class User extends IDObject implements UserAttributesSchema {
    id: string;
    username: string;
    roles: string[];
    version: number;
    groups: Relationship<Group>[];
    constructor(schem: UserSchema);
    /**
     * Retrieves a user by their id
     */
    static get(id: string): Promise<User>;
    /**
     * Retrieves a list of users according to the specified search parameters
     */
    static search(query?: UserSearchParams): Promise<User[]>;
    /**
     * Retrieves an array of users by an array of ids
     */
    static getMultiple(ids: string[]): Promise<User[]>;
    /**
     * Performs a search for a user and returns the first one found. If no results are
     * found, null is returned
     */
    static getByQuery(query?: UserSearchParams): Promise<User | null>;
    /**
     * Returns a user object for the currently authenticated user.
     */
    static getLoggedInUser(): Promise<User>;
    /**
     * Returns all users followed by the currently authenticated user.
     */
    static getFollowedUsers(query?: FollowedUserParams): Promise<User[]>;
}

type ChapterSearchParams = Partial<Merge<GetChapterParamsSchema, {
    ids: Chapter[];
    groups: Group[];
    uploader: User | User[];
}>>;
type OtherChapterAttributes = Omit<ChapterAttributesSchema, 'uploader'>;
type ChapterStatsResponse = DeepRequire<Statistics.GetStatisticsChapters.ResponseBody>;
type ChapterStats = ChapterStatsResponse['statistics'][string];
declare class Chapter extends IDObject implements OtherChapterAttributes {
    /**
     * The MangaDex UUID of this chapter
     */
    id: string;
    /**
     * The title of this chapter
     */
    title: string | null;
    /**
     * The manga volume this chapter belongs to
     */
    volume: string | null;
    /**
     * The chapter number for this chapter
     */
    chapter: string | null;
    /**
     * The number of pages in this chapter
     */
    pages: number;
    /**
     * The language of this chapter
     */
    translatedLanguage: string;
    /**
     * Relationship to the user who uploaded this chapter
     */
    uploader: Relationship<User>;
    /**
     * Url to this chapter if it's an external chapter
     */
    externalUrl: string | null;
    /**
     * The version of this chapter (incremented by updating chapter data)
     */
    version: number;
    /**
     * When this chapter was created
     */
    createdAt: Date;
    /**
     * When this chapter was last updated
     */
    updatedAt: Date;
    /**
     * When this chapter was originally published
     */
    publishAt: Date;
    /**
     * When was / when will this chapter be readable?
     */
    readableAt: Date;
    /**
     * Is this chapter an external chapter? If it is, this chapter will have an externalUrl
     */
    isExternal: boolean;
    /**
     * A relationship to the manga this chapter belongs to
     */
    manga: Relationship<Manga>;
    /**
     * Array of relationships to the groups that translated this chapter
     */
    groups: Relationship<Group>[];
    constructor(schem: ChapterSchema);
    /**
     * Retrieves a chapter object by its UUID
     */
    static get(id: string, expandedTypes?: ChapterSearchParams['includes']): Promise<Chapter>;
    /**
     * Retrieves an array of chapters by an array of their ids
     */
    static getMultiple(ids: string[]): Promise<Chapter[]>;
    /**
     * Retrieves a list of chapters according to the specified search parameters
     */
    static search(query?: ChapterSearchParams): Promise<Chapter[]>;
    /**
     * Performs a search for a chapter and returns the first one found. If no results are
     * found, null is returned
     */
    static getByQuery(query?: ChapterSearchParams): Promise<Chapter | null>;
    /**
     * Update this chapter's information
     */
    update(data: Omit<ChapterEditSchema, 'version'>): Promise<Chapter>;
    /**
     * Delete this chapter
     */
    static delete(id: string): Promise<void>;
    /**
     * Delete a chapter by its UUID
     */
    delete(): Promise<void>;
    /**
     * Returns an array of image URLs for this chapter's pages. Once an image is requested,
     * if the host is from MangaDex(at)Home, please report if it succeeds or fails by using {@link reportPageURL}.
     * @param saver - If true, the URLs will be for the compressed data-saver images (if available).
     * @param forcePort - If true, the URLs will be forced to be on port 443.
     */
    getReadablePages(saver?: boolean, forcePort?: boolean): Promise<string[]>;
    /**
     * Sends a report to MangaDex about the success/failure of a MangaDex(at)Home server.
     * Read more information: {@link https://api.mangadex.org/docs/04-chapter/retrieving-chapter/#mangadexhome-load-successes-failures-and-retries}
     */
    static reportPageURL(report: {
        url: string;
        success: boolean;
        bytes: number;
        duration: number;
        cached: boolean;
    }): Promise<void>;
    /**
     * Gets the statistics about a list of chapters
     */
    static getStatistics(ids: string[] | Chapter[]): Promise<Record<string, ChapterStats>>;
    /**
     * Gets the statistics about this chapter
     */
    getStatistics(): Promise<ChapterStats>;
}

type CoverSearchParams = Partial<Merge<GetCoverParamsSchema, {
    ids: Cover[];
    manga: Manga[];
}>>;
type CoverExpandedTypes = CoverSearchParams['includes'];
type CoverUploadBody = Omit<Cover$1.UploadCover.RequestBody, 'file'> & {
    file: Blob;
};
declare class Cover extends IDObject implements CoverAttributesSchema {
    /**
     * MangaDex UUID for this object
     */
    id: string;
    /**
     * What volume is this cover for, if any
     */
    volume: string | null;
    /**
     * The file name of this cover's image
     */
    fileName: string;
    /**
     * Description of this cover. May be an empty string
     */
    description: string | null;
    /**
     * What language is this cover in
     */
    locale: string | null;
    /**
     * The version of this cover (incremented by updating the cover)
     */
    version: number;
    /**
     * The date this cover was uploaded
     */
    createdAt: Date;
    /**
     * The date this cover was last updated
     */
    updatedAt: Date;
    /**
     * Url to this cover's image
     */
    url: string;
    /**
     * Relationship to the manga this cover belongs to
     */
    manga: Relationship<Manga>;
    /**
     * Relationship to the user who uploaded this cover
     */
    uploader: Relationship<User>;
    constructor(schem: CoverSchema);
    /**
     * Retrieves a cover by its id
     */
    static get(id: string | Manga, expandedTypes?: CoverExpandedTypes): Promise<Cover>;
    /**
     * Retrieves a list of covers according to the specified search parameters
     */
    static search(query?: CoverSearchParams): Promise<Cover[]>;
    /**
     * Performs a search for a cover and returns the first one found. If no results are
     * found, null is returned
     */
    static getByQuery(query?: CoverSearchParams): Promise<Cover | null>;
    /**
     * Retrieves an array of covers by an array of ids
     */
    static getMultiple(ids: string[]): Promise<Cover[]>;
    /**
     * Returns an array of covers from an array of manga ids or a single manga
     */
    static getMangaCovers(manga: Manga | string | Manga[] | string[], expandedTypes?: CoverExpandedTypes): Promise<Cover[]>;
    /**
     * Deletes a cover by their id
     */
    static delete(id: string): Promise<void>;
    /**
     * Deletes this cover
     */
    delete(): Promise<void>;
    /**
     * Updates a cover's information.
     */
    update(data: Omit<CoverEditSchema, 'version'>): Promise<Cover>;
    /**
     * Uploads a new cover
     */
    static create(manga: string | Manga, data: CoverUploadBody): Promise<Cover>;
}

type AuthorSearchParams = Partial<Merge<GetAuthorParamsSchema, {
    ids: Author[];
}>>;
/**
 * This represents an author or artist of a manga
 */
declare class Author extends IDObject implements AuthorAttributesSchema {
    /**
     * The MangaDex UUID for the author/artist
     */
    id: string;
    /**
     * The name of the author/artist
     */
    name: string;
    /**
     * A url to an image of the author/artist
     */
    imageUrl: string | null;
    /**
     * The biography of the author/artist
     */
    biography: LocalizedString;
    /**
     * URL to the author/artist's twitter
     */
    twitter: string | null;
    /**
     * URL to the author/artist's pixiv
     */
    pixiv: string | null;
    /**
     *  URL to the author/artist's melon book
     */
    melonBook: string | null;
    /**
     *  URL to the author/artist's fanbox
     */
    fanBox: string | null;
    /**
     *  URL to the author/artist's booth
     */
    booth: string | null;
    /**
     *  URL to the author/artist's nico video
     */
    nicoVideo: string | null;
    /**
     *  URL to the author/artist's skeb
     */
    skeb: string | null;
    /**
     *  URL to the author/artist's fantia
     */
    fantia: string | null;
    /**
     *  URL to the author/artist's tumblr
     */
    tumblr: string | null;
    /**
     *  URL to the author/artist's youtube
     */
    youtube: string | null;
    /**
     *  URL to the author/artist's weibo
     */
    weibo: string | null;
    /**
     *  URL to the author/artist's naver
     */
    naver: string | null;
    /**
     * URL to the author/artist's namicomi
     */
    namicomi: string | null;
    /**
     *  URL to the author/artist's website
     */
    website: string | null;
    /**
     *  The version of this author/artist's entry (incremented by updating author data)
     */
    version: number;
    /**
     * When the author/artist's entry was added
     */
    createdAt: Date;
    /**
     * The last time the author/artist's entry was updated
     */
    updatedAt: Date;
    /**
     * The manga the author/artist has worked on
     */
    manga: Relationship<Manga>[];
    constructor(schem: AuthorSchema);
    /**
     * Retrieve a chapter object by its id
     */
    static get(id: string, expandedTypes?: AuthorSearchParams['includes']): Promise<Author>;
    /**
     * Retrieves a list of authors/artists according to the specified search parameters
     */
    static search(query?: AuthorSearchParams): Promise<Author[]>;
    /**
     * Performs a search for an author/artist and returns the first one found. If no results are
     * found, null is returned
     */
    static getByQuery(query?: AuthorSearchParams): Promise<Author | null>;
    /**
     * Retrieves an array of authors/artists by an array of ids
     */
    static getMultiple(ids: string[]): Promise<Author[]>;
    /**
     * Create a new Author
     */
    static create(data: AuthorCreateSchema): Promise<Author>;
    /**
     * Deletes an author by their id
     */
    static delete(id: string): Promise<void>;
    /**
     * Deletes this author
     */
    delete(): Promise<void>;
    /**
     * Updates an author's information.
     */
    update(data: Omit<AuthorCreateSchema, 'version'>): Promise<Author>;
}

type MangaSearchHelpers = {
    group: Group;
    includedTags: Tag[];
    excludedTags: Tag[];
    authors: Author[];
    artists: Author[];
    authorOrArtist: Author;
    ids: IDObject[];
};
type MangaSearchParams = Partial<Merge<GetSearchMangaParamsSchema, MangaSearchHelpers>>;
type OtherMangaAttributes = Omit<MangaAttributesSchema, 'tags' | 'links' | 'latestUploadedChapter'>;
type RelatedManga = {
    [x in RelationshipSchema['related']]: Relationship<Manga>[];
};
type MangaReadingStatus = Required<Manga$1.GetMangaIdStatus.ResponseBody>['status'];
type MangaRelation = MangaRelationAttributesSchema['relation'];
type MangaStatsResponse = DeepRequire<Statistics.GetStatisticsManga.ResponseBody>;
type MangaStats = MangaStatsResponse['statistics'][string];
type MangaDraftSearchParams = Partial<GetMangaDraftsParamsSchema>;
type MangaAggregateResponse = DeepRequire<Manga$1.GetMangaAggregate.ResponseBody>;
type MangaAggregate = MangaAggregateResponse['volumes'];
type FollowedMangaParams = User$1.GetUserFollowsManga.RequestQuery;
/**
 * This class represents a specific manga series.
 * There are many static methods for requesting manga from MangaDex.
 */
declare class Manga extends IDObject implements OtherMangaAttributes {
    /**
     * The MangaDex UUID of this manga
     */
    id: string;
    /**
     * The manga's main title with different localization options
     */
    title: LocalizedString;
    /**
     * List of alternate titles with different localization options
     */
    altTitles: LocalizedString[];
    /**
     * Description with different localization options
     */
    description: LocalizedString;
    /**
     * Is this manga locked?
     */
    isLocked: boolean;
    /**
     * Link object representing links to other websites about this manga
     */
    links: Links;
    /**
     * 2 (or more) letter code for the original language of this manga
     */
    originalLanguage: string;
    /**
     * This manga's last volume based on the default feed order
     */
    lastVolume: string | null;
    /**
     * This manga's last chapter based on the default feed order
     */
    lastChapter: string | null;
    /**
     * Publication demographic of this manga
     */
    publicationDemographic: 'shounen' | 'shoujo' | 'josei' | 'seinen' | null;
    /**
     * Publication/Scanlation status of this manga
     */
    status: 'completed' | 'ongoing' | 'cancelled' | 'hiatus';
    /**
     * Year of this manga's publication
     */
    year: number | null;
    /**
     * The content rating of this manga
     */
    contentRating: 'safe' | 'suggestive' | 'erotica' | 'pornographic';
    /**
     * Does the chapter count reset whenever a new volume is added?
     */
    chapterNumbersResetOnNewVolume: boolean;
    /**
     * List of language codes that this manga has translated chapters for
     */
    availableTranslatedLanguages: string[];
    /**
     * UUID of the chapter that was uploaded last.
     * String is empty if there is no chapter
     */
    latestUploadedChapter: Relationship<Chapter>;
    /**
     * List of this manga's genre tags
     */
    tags: Tag[];
    /**
     * Status of this manga as a manga submission
     */
    state: 'draft' | 'submitted' | 'published' | 'rejected';
    /**
     * The version of this manga (incremented by updating manga data)
     */
    version: number;
    /**
     * Date the manga was added to the site
     */
    createdAt: Date;
    /**
     * Date the manga was last updated
     */
    updatedAt: Date;
    /**
     * An object containing all other manga entries related to this one.
     * This includes spin-offs, colorization, etc.
     */
    relatedManga: RelatedManga;
    /**
     * List of relationships to authors attributed to this manga
     */
    authors: Relationship<Author>[];
    /**
     * List of relationships to artists attributed to this manga
     */
    artists: Relationship<Author>[];
    /**
     * A relationship to the current main cover of this series
     */
    mainCover: Relationship<Cover>;
    constructor(schem: MangaSchema);
    private static getRelatedManga;
    /**
     * The title of this manga according to the global locale.
     * @see {@link LocalizedString.localString}
     */
    get localTitle(): string;
    /**
     * List of alternate titles for manga according to the global locale.
     * @see {@link LocalizedString.localString}
     */
    get localAltTitles(): string[];
    /**
     * The description of this manga according to the global locale.
     * @see {@link LocalizedString.localString}
     */
    get localDescription(): string;
    /**
     * Retrieves a manga object by its UUID
     */
    static get(id: string, expandedTypes?: MangaSearchParams['includes']): Promise<Manga>;
    /**
     * Retrieves a list of manga according to the specified search parameters
     * @see {@link Relationship.cached} for information on how to automatically resolve Relationships
     */
    static search(query?: MangaSearchParams): Promise<Manga[]>;
    /**
     * Retrieves an array of manga by an array of their ids
     */
    static getMultiple(ids: string[], extraParams?: Omit<MangaSearchParams, 'ids'>): Promise<Manga[]>;
    /**
     * Returns how many manga there are total for a search query
     */
    static getTotalSearchResults(query?: Omit<MangaSearchParams, 'limit' | 'offset'>): Promise<number>;
    /**
     * Returns an array of a manga's chapters
     */
    static getFeed(id: string, params?: ChapterSearchParams): Promise<Chapter[]>;
    /**
     * Returns an array of this manga's chapters
     */
    getFeed(params?: ChapterSearchParams): Promise<Chapter[]>;
    /**
     * Marks lists of chapters read or unread for a single manga
     */
    static updateReadChapters(manga: string, chapters: {
        read?: (string | Chapter)[];
        unread?: (string | Chapter)[];
    }, updateHistory?: boolean): Promise<never[] | undefined>;
    /**
     * Marks lists of chapters read or unread for this manga
     */
    updateReadChapters(chapters: Parameters<typeof Manga.updateReadChapters>[1], updateHistory?: boolean): Promise<never[] | undefined>;
    /**
     * Returns an array of read chapters for a list of manga. The response is a record with the manga ids
     * as the keys and chapter arrays as the values.
     */
    static getReadChapters(ids: string[] | Manga[]): Promise<Record<string, Chapter[]>>;
    /**
     * Returns an array of read chapters for this manga
     */
    getReadChapters(): Promise<Chapter[]>;
    /**
     * Retrieves a random manga
     */
    static getRandom(query?: Pick<MangaSearchParams, keyof GetMangaRandomParamsSchema>): Promise<Manga>;
    /**
     * Performs a search for a manga and returns the first one found. If no results are
     * found, null is returned
     */
    static getByQuery(query?: MangaSearchParams): Promise<Manga | null>;
    /**
     * Gets all covers for this manga
     */
    getCovers(): Promise<Cover[]>;
    /**
     * Returns all manga followed by the currently authenticated user
     */
    static getFollowedManga(query?: FollowedMangaParams): Promise<Manga[]>;
    /**
     * Returns a record of all ratings given by the currently authenticated user. The object is indexed by the manga
     * ids and each value contains the numerical rating and when that rating was given. If a manga has no rating,
     * 'null' is used as the value.
     */
    static getUserRatings(ids: string[] | Manga[]): Promise<Record<string, {
        rating: number;
        createdAt: Date;
    } | null>>;
    /**
     * Returns the rating that the currently authenticated user gave to this manga on a scale of 1-10,
     * or returns null if there is no rating.
     */
    getUserRating(): Promise<number | null>;
    /**
     * Makes the currently authenticated user give a manga a rating between 1-10 (inclusive).
     */
    static giveRating(mangaId: string, rating: number): Promise<void>;
    /**
     * Makes the currently authenticated user give this manga a rating between 1-10 (inclusive).
     */
    giveRating(rating: number): Promise<void>;
    /**
     * Removes the currently authenticated user's rating for a manga
     */
    static removeRating(mangaId: string): Promise<void>;
    /**
     * Removes the currently authenticated user's rating for this manga
     */
    removeRating(): Promise<void>;
    /**
     * Gets the combined feed of every manga followed by the logged in user
     */
    static getFollowedFeed(query?: ChapterSearchParams): Promise<Chapter[]>;
    /**
     * Converts legacy pre-V5 MangaDex ids to modern UUIDs. Returns a record with legacy ids as the keys
     * and new ids as the values.
     */
    static convertLegacyId(type: MappingIdBodySchema['type'], ids: number[]): Promise<Record<number, string>>;
    /**
     * Get every reading status (eg completed, reading, dropped, etc) for every manga marked by
     * the currently authenticated user.
     * @param filter - If specified, only manga with this status will be returned
     */
    static getAllReadingStatus(filter?: MangaReadingStatus): Promise<Record<string, MangaReadingStatus>>;
    /**
     * Gets the reading status (eg completed, reading, dropped, etc) for a manga for the currently
     * authenticated user
     */
    static getReadingStatus(id: string): Promise<MangaReadingStatus>;
    /**
     * Gets the reading status (eg completed, reading, dropped, etc) for this manga for the currently
     * authenticated user
     */
    getReadingStatus(): Promise<MangaReadingStatus>;
    /**
     * Sets a manga's reading status (eg completed, reading, dropped, etc) for the currently authenticated user.
     * If the status is null, the current reading status will be removed.
     */
    static setReadingStatus(id: string, status: MangaReadingStatus | null): Promise<void>;
    /**
     * Sets this manga's reading status (eg completed, reading, dropped, etc) for the currently authenticated user.
     * If the status is null, the current reading status will be removed.
     */
    setReadingStatus(status: MangaReadingStatus | null): Promise<void>;
    /**
     * Gets all of a manga's relations to other manga.
     */
    static getRelations(id: string, expandTypes?: boolean): Promise<RelatedManga>;
    /**
     * Gets all of this manga's relations to other manga.
     */
    getRelations(expandTypes?: boolean): Promise<RelatedManga>;
    /**
     * Creates a relation between two manga (eg sequel/prequel, monochrome/colored, spin-off, etc)
     * @param id - The origin manga
     * @param targetId - The target manga for the relation (eg the sequel, spin-off, etc)
     */
    static addRelation(id: string, targetId: string, relationType: MangaRelation): Promise<void>;
    /**
     * Creates a relation (eg sequel/prequel, monochrome/colored, spin-off, etc) between this manga and another
     * @param id - The origin manga
     * @param targetId - The target manga for the relation (eg the sequel, spin-off, etc)
     */
    addRelation(targetId: string, relationType: MangaRelation): Promise<void>;
    /**
     * Removes a relation from a manga by the relation's id
     */
    static removeRelation(mangaId: string, relationId: string): Promise<void>;
    /**
     * Removes a relation from this manga by the relation's id
     */
    removeRelation(relationId: string): Promise<void>;
    /**
     * Gets the statistics about manga including their rating distribution, comment count, and follow count
     */
    static getStatistics(ids: string[] | Manga[]): Promise<Record<string, MangaStats>>;
    /**
     * Gets the statistics about this manga including its rating distribution, comment count, and follow count
     */
    getStatistics(): Promise<MangaStats>;
    /**
     * Retrieves a manga draft by its UUID
     */
    static getDraft(id: string, expandedTypes?: MangaDraftSearchParams['includes']): Promise<Manga>;
    /**
     * Retrieves a list of manga drafts according to the specified search parameters
     * @see {@link Relationship.cached} for information on how to automatically resolve Relationships
     */
    static searchDrafts(query?: MangaDraftSearchParams): Promise<Manga[]>;
    /**
     * Commits a manga object as a draft. A Manga draft that is to be submitted must have at least one cover in
     * the original language, must be in the "draft" state, and must be passed the correct version in the request body.
     */
    static commitDraft(draftId: string, manga: Partial<MangaAttributesSchema>): Promise<Manga>;
    /**
     * Create a new manga. MangaDex only allows admins to use this endpoint. Use the a manga draft instead
     */
    static create(data: MangaCreateSchema): Promise<Manga>;
    /**
     * Deletes a manga by its id
     */
    static delete(id: string): Promise<void>;
    /**
     * Deletes this manga
     */
    delete(): Promise<void>;
    /**
     * Updates this manga's information.
     */
    update(data: Omit<MangaCreateSchema, 'version'>): Promise<Manga>;
    /**
     * Returns an abridged list of chapter ids for a manga separated by their volumes
     */
    static getAggregate(id: string, groups?: string[] | Group[], languages?: string[]): Promise<MangaAggregate>;
    /**
     * Returns an abridged list of chapter ids for this manga separated by their volumes
     */
    getAggregate(groups?: string[] | Group[], languages?: string[]): Promise<MangaAggregate>;
    /**
     * Makes the logged in user follow or unfollow a manga
     */
    static changeFollowship(id: string, follow?: boolean): Promise<void>;
    /**
     * Makes the user follow or unfollow this manga
     */
    changeFollowship(follow?: boolean): Promise<void>;
}

type FullUploadSession = UploadSessionSchema & {
    relationships: RelationshipSchema[];
};
type FixedFullUploadSession = FullUploadSession | {
    data: FullUploadSession;
};
/**
 * This class represents an in-progress manga upload session including the uploaded pages.
 */
declare class UploadSession extends IDObject implements UploadSessionAttributesSchema {
    /**
     * The MangaDex UUID of this upload session
     */
    id: string;
    /**
     * Has this session been committed (pages published)
     */
    isCommitted: boolean;
    /**
     * Has this session still been processed by MangaDex?
     */
    isProcessed: boolean;
    /**
     * Has this session been deleted/aborted?
     */
    isDeleted: boolean;
    /**
     * The version of this session (incremented by updating data)
     */
    version: number;
    /**
     * When this upload session was started
     */
    createdAt: Date;
    /**
     * When this upload session was last updated
     */
    updatedAt: Date;
    /**
     * A relationship to who started this upload session
     */
    uploader: Relationship<User>;
    /**
     * A relationship to the manga this upload session is for
     */
    manga: Relationship<Manga>;
    /**
     * An array of relationships to the groups involved with the chapter for this session
     */
    groups: Relationship<Group>[];
    /**
     * An array of uploaded page image files
     */
    pages: UploadSessionFile[];
    constructor(schem: FixedFullUploadSession);
    private updateData;
    /**
     * Begin a new upload session for a specified manga. At least one group must be specified
     * @param cancelCurrentSession - Stop any current upload session before creating this one
     */
    static begin(manga: string | Manga, groups?: string[] | Group[], cancelCurrentSession?: boolean): Promise<UploadSession>;
    /**
     * Start a new upload session for editing an existing chapter. The upload session will
     * act the same as one for new chapter.
     * @param cancelCurrentSession - Stop any current upload session before creating this one
     */
    static beginChapterEdit(chapter: Chapter, cancelCurrentSession?: boolean): Promise<UploadSession>;
    /**
     * Get the current upload session owned by the currently authenticated user
     */
    static getCurrentSession(): Promise<UploadSession>;
    /**
     * Cancel the current user's current upload session if it exists
     */
    static cancelCurrentSession(): Promise<void>;
    /**
     * Closes this upload session and removes all associated uploaded files
     */
    close(): Promise<void>;
    /**
     * Commit and publish this chapter to MangaDex.
     * @param pageOrder - By default, the page order is decided by the 'pages' array of this upload session object.
     * If this parameter is supplied an array, the order of elements in that array is used instead.
     */
    commit(chapterData: ChapterDraftSchema, pageOrder?: string[] | UploadSessionFile[]): Promise<void>;
    /**
     * Upload new page image files as blobs. The blobs should contain the binary image data, and although not necessary,
     * it is recommended that the image MIME type is included as well. The resulting uploaded file data will be appended
     * to this object's 'pages' property.
     */
    uploadPages(files: Blob[]): Promise<void>;
    /**
     * Delete previously uploaded page image files by their ids
     */
    deletePages(pages: string[] | UploadSessionFileSchema[]): Promise<void>;
}
declare class UploadSessionFile extends IDObject implements UploadSessionFileAttributesSchema {
    /**
     * The MangaDex UUID of this uploaded file
     */
    id: string;
    /**
     * The original filename of the file. May be an empty string
     */
    originalFileName: string;
    /**
     * The hash of this file. May be an empty string
     */
    fileHash: string;
    /**
     * The file size in bytes of this file
     */
    fileSize: number;
    /**
     * The MIME image type of this file
     */
    mimeType: string;
    /**
     * Is this file stored on MangaDex's server or elsewhere
     */
    source: 'local' | 'remote';
    /**
     * The version number of this file (incremented by updating the file's data)
     */
    version: number;
    /**
     * A number assigned to this file. It is usually from the order it was uploaded, but it can also
     * be the file hash or another number.
     */
    num: number;
    constructor(schem: UploadSessionFileSchema);
}

type PersonalClientInfo = {
    username: string;
    password: string;
    clientId: string;
    clientSecret: string;
};
type ClientData = PersonalClientInfo & {
    accessToken: string;
    accessExpiration: number;
    refreshToken: string;
    refreshExpiration: number;
};
/**
 * This class is used to authenticate with the MangaDex API using a personal client.
 * {@link https://api.mangadex.org/docs/02-authentication/personal-clients/}
 */
declare class PersonalAuthClient implements IAuthClient {
    data: ClientData;
    constructor(data: ClientData);
    /**
     * Returns the client's access token and refreshes it if necessary.
     */
    getSessionToken(): Promise<string>;
    /**
     * Refreshes the client's access token and refresh token.
     */
    refreshTokens(): Promise<void>;
    /**
     * Creates a new PersonalAuthClient and optionally sets it as the active client.
     */
    static login(info: PersonalClientInfo, activate?: boolean): Promise<PersonalAuthClient>;
}

type LoginData = {
    session: string;
    refresh: string;
    timestamp: number;
};
/**
 * This class represents a the legacy (username and password) auth client.
 * This login method is being deprecated in favor of OAuth which is implemented through {@link PersonalAuthClient} instead.
 *
 * @deprecated - This login method is being replaced by OAuth
 */
declare class LegacyAuthClient implements IAuthClient {
    data: LoginData;
    constructor(data: LoginData);
    getSessionToken(): Promise<string>;
    /**
     * Set this auth instance to be the one used by all API calls
     */
    setActive(): void;
    /**
     * Login with a legacy username and password, and activate this client for all API calls
     */
    static login(username: string, password: string): Promise<LegacyAuthClient>;
    /**
     * Refresh the access token and update the token data for this client
     */
    refreshTokens(): Promise<void>;
    /**
     * Check if the current session token is valid by asking MangaDex
     */
    checkSessionToken(): Promise<boolean>;
}

declare class List extends IDObject implements CustomListAttributesSchema {
    /**
     * The MangaDex UUID of this custom list
     */
    id: string;
    /**
     * The display name of this custom list
     */
    name: string;
    /**
     * Is this list public or private?
     */
    visibility: 'private' | 'public';
    /**
     * The version of this custom list (incremented by updating data)
     */
    version: number;
    /**
     * A relationship to the user who created and owns this list
     */
    creator: Relationship<User>;
    /**
     * An array of relationships to the manga in this custom list
     */
    manga: Relationship<Manga>[];
    constructor(schem: CustomListSchema);
    /**
     * Retrieves a list by its id
     */
    static get(id: string): Promise<List>;
    /**
     * Create a new list
     */
    static create(data: CustomListCreateSchema): Promise<List>;
    /**
     * Deletes a list by its id
     */
    static delete(id: string): Promise<void>;
    /**
     * Deletes this list
     */
    delete(): Promise<void>;
    /**
     * Updates a list's information.
     */
    update(data: Partial<Omit<CustomListCreateSchema, 'version'>>): Promise<List>;
    /**
     * Make the currently authenticated user follow a list
     */
    static follow(id: string): Promise<void>;
    /**
     * Make the currently authenticated user follow this list
     */
    follow(): Promise<void>;
    /**
     * Make the currently authenticated user unfollow a list
     */
    static unfollow(id: string): Promise<void>;
    /**
     * Make the currently authenticated user unfollow this list
     */
    unfollow(): Promise<void>;
    /**
     * Add a manga to a list
     */
    static addManga(listId: string, manga: Manga | string): Promise<void>;
    /**
     * Add a manga to this list
     */
    addManga(manga: Manga | string): Promise<void>;
    /**
     * Remove a manga from a list
     */
    static removeManga(listId: string, manga: Manga | string): Promise<void>;
    /**
     * Remove a manga from this list
     */
    removeManga(manga: Manga | string): Promise<void>;
    /**
     * Returns all of the currently authenticated user's custom manga lists
     */
    static getLoggedInUserLists(limit?: number, offset?: number): Promise<List[]>;
    /**
     * Returns all of a user's custom manga lists
     */
    static getUserLists(user: string | User, limit?: number, offset?: number): Promise<List[]>;
    /**
     * Returns an array of chapters from the manga in a list
     */
    static getFeed(listId: string, query?: Partial<GetListIdFeedParamsSchema>): Promise<Chapter[]>;
    /**
     * Returns an array of chapters from the manga in this list
     */
    getFeed(query?: Partial<GetListIdFeedParamsSchema>): Promise<Chapter[]>;
    /**
     * Returns all lists followed by the currently authenticated user
     */
    static getFollowedLists(limit?: number, offset?: number): Promise<List[]>;
    /**
     * Changes the visibility of this custom list
     */
    changeVisibility(newVis: 'public' | 'private'): Promise<List>;
    /**
     * Renames this custom list
     */
    rename(name: string): Promise<List>;
    /**
     *
     */
    updateMangaList(newList: Manga[] | string[]): Promise<List>;
}

/**
 * If true the debug (sandbox) MangaDex domain wil be used instead of the default one.
 * {@link https://sandbox.mangadex.dev}
 */
declare function useDebugServer(val: boolean): void;
/**
 * Removes the current active AuthClient so no further API calls are done with user authorization
 */
declare function clearActiveAuthClient(): void;
/**
 * Returns the current auth client or null if there is none
 */
declare function getActiveAuthClient(): IAuthClient | null;

/**
 * Sets the global language locale to be used by LocalString objects.
 */
declare const setGlobalLocale: typeof LocalizedString.setGlobalLocale;
/**
 * This will {@link Relationship.resolve} an array of relationships, returning another array
 * in the same order.
 * @param relationshipArray - An array of relationships of the same type
 */
declare const resolveArray: typeof Relationship.resolveAll;
/**
 * Converts old (pre v5, numeric ids) Mangadex ids to v5 ids. Any invalid legacy ids will be
 * skipped by Mangadex when remapping, so call this function for each individual id if this is an issue.
 */
declare const convertLegacyId: typeof Manga.convertLegacyId;

/**
 * Login with a legacy username and password
 *
 * @deprecated - This login method is being replaced by OAuth
 *
 * @param username - Username of the account
 * @param password - Password of the account
 */
declare const login: typeof LegacyAuthClient.login;

/**
 * Login with a personal client. This method is recommended for smaller, private applications.
 * {@link https://api.mangadex.org/docs/02-authentication/personal-clients/}
 * @param clientInfo - Personal client info including client secret/id, username, and password
 * @param activate - By default, this client will be set as the active client for all API calls. Set this to false to disable this behavior.
 */
declare const loginPersonal: typeof PersonalAuthClient.login;

/**
 * This will clear the active auth client, effectively logging out.
 */
declare const logout: typeof clearActiveAuthClient;
/**
 * This will return the current active auth client, if any.
 */
declare const getCurrentAuthClient: typeof getActiveAuthClient;

export { Author, Chapter, Cover, Group, LegacyAuthClient, List, Manga, PersonalAuthClient, Tag, UploadSession, User, convertLegacyId, getCurrentAuthClient, login, loginPersonal, logout, resolveArray, setGlobalLocale, useDebugServer };
